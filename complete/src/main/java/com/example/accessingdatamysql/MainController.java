package com.example.accessingdatamysql;

import io.opentelemetry.api.GlobalOpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.metrics.LongCounter;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.SpanKind;
import io.opentelemetry.api.trace.StatusCode;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Context;
import io.opentelemetry.context.Scope;
import io.opentelemetry.context.propagation.TextMapGetter;
import io.opentelemetry.context.propagation.TextMapSetter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import javax.security.sasl.AuthenticationException;
import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;

import static io.opentelemetry.semconv.trace.attributes.SemanticAttributes.*;

@Controller    // This means that this class is a Controller
@RequestMapping(path = "/demo") // This means URL's start with /demo (after Application path)
public class MainController {
	public static final String USERNAME_HEADER = "username";
	private final Logger log = LoggerFactory.getLogger(MainController.class);


	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;
	private final Tracer tracer;
	private final Meter meter;
	private final LongCounter requestCounter;

	public MainController(UserRepository userRepository) {
		this.userRepository = userRepository;

		tracer = GlobalOpenTelemetry.getTracer(MainController.class.getSimpleName());
		meter = GlobalOpenTelemetry.getMeter(MainController.class.getSimpleName());
		requestCounter = meter.counterBuilder("my.request.count").build();
	}

	private void recordGetRequest(String httpRoute) {
		Attributes counterAttributes = Attributes.of(
				HTTP_METHOD, "GET",
				HTTP_ROUTE, httpRoute
		);
		requestCounter.add(1, counterAttributes);
	}

	@PostMapping(path = "/add") // Map ONLY POST Requests
	public @ResponseBody String addNewUser(@RequestParam String name
			, @RequestParam String email) {
		recordGetRequest("/add");
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		User n = new User();
		n.setName(name);
		n.setEmail(email);
		userRepository.save(n);
		return "Saved";
	}

	@GetMapping(path = "/all")
	public @ResponseBody Iterable<User> getAllUsers(@RequestHeader(USERNAME_HEADER) String username) {
		recordGetRequest("/all");

		Span getUsersSpan = tracer.spanBuilder("getAllUsers")
				.startSpan();

		try (Scope scope = getUsersSpan.makeCurrent()) {
			// Start a span for remote authentication
			Span remoteAuthSpan = tracer
					.spanBuilder("GET /demo/auth")
					.setAttribute(HTTP_METHOD, "GET")
					.setAttribute(HTTP_ROUTE, "/demo/all")
					.startSpan();

			try (Scope authScope = remoteAuthSpan.makeCurrent()) {
				URL url = new URL("http://localhost:8080/demo/auth");
				HttpURLConnection con = (HttpURLConnection) url.openConnection();

				// add the current context (e.g. Trace ID) to the request headers.
				GlobalOpenTelemetry.getPropagators().getTextMapPropagator().inject(Context.current(), con, setter);

				con.setRequestProperty(USERNAME_HEADER, username);

				// When the response is received, more info can be added to the span.
				int responseCode = con.getResponseCode();
				remoteAuthSpan.setAttribute(HTTP_STATUS_CODE, responseCode);
				if (responseCode != 200) {
					throw new AuthenticationException("Could not authenticate. Authentication server returned " + responseCode);
				}
			} catch (IOException e) {
				// record the exception on the span, then wrap the exception into an internal server error exception.
				remoteAuthSpan.recordException(e);
				remoteAuthSpan.setStatus(StatusCode.ERROR);
				throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error in authorization service", e);
			} finally {
				remoteAuthSpan.end();
			}

			log.info("authentication successful, retrieving data from database.");
			return userRepository.findAll();
		} catch (RuntimeException e) {
			getUsersSpan.setStatus(StatusCode.ERROR);
			getUsersSpan.recordException(e);
			throw e;
		} finally {
			getUsersSpan.end();
		}
	}

	@GetMapping(path = "/auth")
	public @ResponseBody void authenticate(@RequestHeader Map<String, String> headers) {
		recordGetRequest("/auth");

		Context extractedContext = GlobalOpenTelemetry.getPropagators().getTextMapPropagator().extract(Context.current(), headers, getter);
		Span authSpan = tracer.spanBuilder("authentication calculation")
				.setParent(extractedContext)
				.setSpanKind(SpanKind.CLIENT)
				.startSpan();

		try (Scope authScope = authSpan.makeCurrent()) {
			if (!headers.containsKey(USERNAME_HEADER)) {
				throw new ResponseStatusException(HttpStatus.BAD_REQUEST, String.format("request is missing '%s' header.", USERNAME_HEADER));
			}
			String myHeader = headers.get(USERNAME_HEADER);
			// some work happening here
			Thread.sleep(300);

			if (myHeader.contains("@")) {
				Thread.sleep(600);
				log.error("Unexpected character '@' in username.");
				throw new IllegalArgumentException("Unexpected input");
			}
		} catch (InterruptedException e) {
			// no need to handle, just for simulating work.
		} catch (IllegalArgumentException e) {
			authSpan.setStatus(StatusCode.ERROR);
			authSpan.recordException(e);
			// wrap the exception in a response status exception with error code 500.
			throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "error during authentication", e);
		} finally {
			authSpan.end();
		}
	}


	TextMapSetter<HttpURLConnection> setter =
			new TextMapSetter<HttpURLConnection>() {
				@Override
				public void set(HttpURLConnection carrier, String key, String value) {
					// Insert the context as Header
					carrier.setRequestProperty(key, value);
				}
			};
	TextMapGetter<Map<String, String>> getter =
			new TextMapGetter<>() {
				@Override
				public Iterable<String> keys(Map<String, String> carrier) {
					return carrier.keySet();
				}

				@Override
				public String get(Map<String, String> carrier, String key) {
					if (carrier.containsKey(key)) {
						return carrier.get(key);
					}
					return null;
				}
			};
}
