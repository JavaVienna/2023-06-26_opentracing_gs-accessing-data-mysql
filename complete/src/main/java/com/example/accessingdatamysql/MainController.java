package com.example.accessingdatamysql;

import io.opentelemetry.api.GlobalOpenTelemetry;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.metrics.LongCounter;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.StatusCode;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import org.apache.tomcat.websocket.AuthenticationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Map;

@Controller    // This means that this class is a Controller
@RequestMapping(path = "/demo") // This means URL's start with /demo (after Application path)
public class MainController {
	public static final String USERNAME_HEADER = "username";
	private final Logger log = LoggerFactory.getLogger(MainController.class);
	private final LongCounter failedAuths;
	private final Tracer tracer;


	@Autowired // This means to get the bean called userRepository
	// Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;

	public MainController(UserRepository userRepository) {
		this.userRepository = userRepository;

		Meter meter = GlobalOpenTelemetry.getMeter(MainController.class.getSimpleName());
		failedAuths = meter.counterBuilder("failed.authentications").build();

		tracer = GlobalOpenTelemetry.getTracer(MainController.class.getSimpleName());
	}

	@PostMapping(path = "/add") // Map ONLY POST Requests
	public @ResponseBody String addNewUser(@RequestParam String name
			, @RequestParam String email) {
		// @ResponseBody means the returned String is the response, not a view name
		// @RequestParam means it is a parameter from the GET or POST request

		User n = new User();
		n.setName(name);
		n.setEmail(email);
		userRepository.save(n);
		return "Saved";
	}

	@GetMapping(path = "/all")
	public @ResponseBody Iterable<User> getAllUsers(@RequestHeader(USERNAME_HEADER) String username) {
		try {
			URL url = new URL("http://localhost:8080/demo/auth");
			HttpURLConnection con = (HttpURLConnection) url.openConnection();

			con.setRequestProperty(USERNAME_HEADER, username);

			int responseCode = con.getResponseCode();

			if (responseCode != 200) {
				throw new AuthenticationException("Could not authenticate. Authentication server returned " + responseCode);
			}
		} catch (IOException | AuthenticationException e) {
			// wrap the exception into an internal server error exception.
			throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error in authorization service", e);
		}

		log.info("authentication successful, retrieving data from database.");
		// This returns a JSON or XML with the users
		return userRepository.findAll();
	}

	@GetMapping(path = "/auth")
	public @ResponseBody void authenticate(@RequestHeader Map<String, String> headers) {
		if (!headers.containsKey(USERNAME_HEADER)) {
			throw new ResponseStatusException(HttpStatus.BAD_REQUEST, String.format("request is missing '%s' header.", USERNAME_HEADER));
		}
		String myHeader = headers.get(USERNAME_HEADER);

		// some work happening here
		try {
			Thread.sleep(300);

			Span span = tracer.spanBuilder("authorization calculation").startSpan();
			try (Scope scope = span.makeCurrent()) {
				if (myHeader.contains("@")) {
					Thread.sleep(600);
					log.error("Unexpected character '@' in username.");
					failedAuths.add(1, Attributes.of(AttributeKey.stringKey("failure_reason"), "unexpected_input"));
					throw new IllegalArgumentException("Unexpected input");
				}
			} catch (IllegalArgumentException e) {
				span.recordException(e);
				span.setStatus(StatusCode.ERROR);
				throw e;
			} finally {
				span.end();
			}
		} catch (InterruptedException e) {
			// no need to handle, just for simulating work.
		} catch (IllegalArgumentException e) {
			// wrap the exception in a response status exception with error code 500.
			throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "error during authentication", e);
		}
	}
}
